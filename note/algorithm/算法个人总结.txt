数组中的常规算法
	1，二分法：常用于题目为已排序的数组，关注是否存有重复问题，存在重复时可能会有特殊情况的出现（二分算法边界的确定尤为重要，left<right?left<=right）
	mid = L + (R - L) / 2 [（L + R）>>> 1 ]

	2，滑动窗口：滑动窗口模板（以下为最长窗口模板）
	《挑战程序设计竞赛》这本书中把滑动窗口叫做「虫取法」
	因为滑动窗口的两个指针移动的过程和虫子爬动的过程非常像：前脚不动，把后脚移动过来；后脚不动，把前脚向前移动。
	
	滑动窗口的模板，能解决大多数的滑动窗口问题：（最小和与最小计数大同小异）
	def findSubArray(nums):
	N = len(nums) # 数组/字符串长度
	left, right = 0, 0 # 双指针，表示当前遍历的区间[left, right]，闭区间
	sums = 0 # 用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
	res = 0 # 保存最大的满足题目要求的 子数组/子串 长度
	while right < N: # 当右边的指针没有搜索到 数组/字符串 的结尾
	    sums += nums[right] # 增加当前右边指针的数字/字符的求和/计数
	    while 区间[left, right]不符合题意：# 此时需要一直移动左指针，直至找到一个符合题意的区间
	        sums -= nums[left] # 移动左指针前需要从counter中减少left位置字符的求和/计数
	        left += 1 # 真正的移动左指针，注意不能跟上面一行代码写反
	    # 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
	    res = max(res, right - left + 1) # 需要更新结果
	    right += 1 # 移动右指针，去探索新的区间
	return res
	
	排序双指针有时可以解决3个或以上变量的问题。
	int i = 0,int[] nums = {-1,-1,0}; while(nums[i] == nums[++i])语句会使得i最终移到元素0的下标处
	一般来说哈希表都是用来快速判断一个元素是否出现集合里

遇到平方想想平方根

快慢指针解决链表一部分问题

树的理论基础


回溯算法的三个要素（重点关注函数功能，以宏观思维来书写）

1，「确定递归函数的参数和返回值：」确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数 ，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

2，「确定终止条件：」写完了递归算法,  运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

3，「确定单层递归的逻辑：」确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

	优先队列（priority）本质上是最小堆最大堆 特别用法可以参考力扣#347 前 K 个高频元素
	树的层次遍历输出，可以采用队列来书写迭代算法。
	力扣131的状态二维数组的赋值方式可供参考，可以保证不乱。
	主对角线已知情况下，赋值上三角，由右下开始赋值[i = n - 1,j = i + 1](i--,j++){i>=0,j<n}；赋值下三角，由左上开始赋值 [i=0,j=i-1](i++,j--){i<n,j>=0} j嵌套在i中
	中序遍历二叉搜索树等于遍历有序数组
	substring提取的字符串无法反转！
	树的递归函数不能使用传来的数组的length，会导致数值固定，应该定义下界和上界，若求中间应该使用m = l + (r - l) / 2 [ (l + r) >>> 1]
	
	常规回溯函数过程伪代码如下：
	
	void backtracking(参数) {
		if (终止条件) {
	    	存放结果;
	    	return;
		}
	
		for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
	    	处理节点;
	    	backtracking(路径，选择列表); // 递归
	    	回溯，撤销处理结果
			}
	}
	
	for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历
	
	递归枚举子序列的通用模板：
	List<List<Integer>> ans = new ArrayList<List<Integer>>();
	List<Integer> temp = new ArrayList<Integer>();
	public void dfs(int cur, int[] nums) {
		if (cur == nums.length) {
	    	// 判断是否合法，如果合法判断是否重复，将满足条件的加入答案
	    	if (isValid() && notVisited()) {
	        	ans.add(new ArrayList<Integer>(temp));
	    	}
	    	return;
		}
		// 如果选择当前元素
		temp.add(nums[cur]);
		dfs(cur + 1, nums);
		temp.remove(temp.size() - 1);
		// 如果不选择当前元素
		dfs(cur + 1, nums);
	}

贪心算法一般分为如下四步：

	将问题分解为若干个子问题
	找出适合的贪心策略
	求解每一个子问题的最优解
	将局部最优解堆叠成全局最优解
	其实这个分的有点细了，真正做题的时候很难分出这么详细的解题步骤，可能就是因为贪心的题目往往还和其他方面的知识混在一起。

数组中的某个元素其左右存在某种约束时，优先考虑一边，详见力扣分发糖果

如果两个维度一起考虑一定会顾此失彼！

看到计算表达式的题目优先想到栈，优化用数学！

局部最优推出全局最优，找不出反例，那么就按照贪心来！

如果某一问题有很多重叠子问题，使用动态规划是最有效的。

动态规划
确定dp数组（dp table）以及下标的含义
确定递推公式
dp数组如何初始化
确定遍历顺序
举例推导dp数组（验证）

一：确认状态
	-最后一步
	-子问题
二：转移方程
三：初始条件和边界情况
	-初始条件：用转移方程算不出来，需要手工定义
	-边界情况：数组不能越界
四：计算顺序举例
二维：从上到下，从左到右
一维：从小到大

二维数组特性
否则，对于 x \in [0, mn)x∈[0,mn)，第 xx 个元素在 \textit{nums}nums 中对应的下标为 (x ~/~ n, x~\%~ n)(x / n,x % n)，而在新的重塑矩阵中对应的下标为 (x ~/~ c, x~\%~ c)(x / c,x % c)。我们直接进行赋值即可。
求两个数组或者字符串的最长公共子序列问题，肯定是要用动态规划的。

对于背包问题，有一种写法，是使用二维数组，即dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。
一定要倒叙遍历，保证某个物品只被放入一次！这一点对01背包很重要，后面在讲解滚动数组的时候，还会用到倒叙遍历来保证物品使用一次！（规定物品只有一个时）

两堆石头对撞想要最后剩下的石头重量最小，相当于在为一半石头总重量的两个背包中放入最大重量，求得的最小差即为剩下的石头的最小重量

假设加法的总和为x，那么减法对应的总和就是sum - x。
所以我们要求的是 x - (sum - x) = S
x = (S + sum) / 2

奇数加奇数之和一定是偶数 奇数加偶数之和

满二叉树的节点数量例子：2^3 + 2^2 + 2^1 + 2^0 = 15（共有16个节点）
可以看出上者不算根节点，总和为等比数列的求和公式

以下两者是在一维背包问题下存在的（多是完全背包问题）
动态规划先物品后背包得到的是组合结果
动态规划先背包后物品得到的是排列结果

在计算树的隔层结果时可以使用一个map把计算过的结果保存一下，这样如果计算过孙子了，那么计算孩子的时候可以复用孙子节点的结果。

后序遍历可以通过递归函数的返回值来做下一步计算。（打家劫舍3）

动规回文串常用循环结构：
        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s.charAt(i) == s.charAt(j)) && (f[i + 1][j - 1] || j - i <= 1);
            }
        }

如果题目关键的部分直接用库函数就可以解决，建议不要使用库函数。

如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。

XOR（异或）运算符：^ 一个数和自己异或为0，一个数和0异或为本身
2^6 = 4 -- 2^4 = 6 
异或查询：可以初始化一个由0开始，后面保留数组异或结果的数组 如：0 1 1^3 1^3^4 (arr={1,3,4})              
	int l = queries[i][0] + 1;
        int r = queries[i][1] + 1;
        ans[i] = xorSum[r] ^ xorSum[l-1];

(pile + speed - 1) / speed  = pile/speed （程序中防止整型取整的写法）

01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了，一位dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。
在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序同样无所谓！
原因：因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。

并查集经典题目 力扣990

数值的整数次方（巧妙的递归解法，将时间复杂度降到了nlogn）
class Solution {
    public double myPow(double x, int n) {
        if(n == 0) return 1;
        if(n == 1) return x;
        if(n == -1) return 1 / x;
        double half = myPow(x, n / 2);
        double mod = myPow(x, n % 2);
        return half * half * mod;
    }
}

预备知识

有限状态自动机其实核心思想也是DP，省去搜寻状态的时间。

确定有限状态自动机（以下简称「自动机」）是一类计算模型。它包含一系列状态，这些状态中：

有一个特殊的状态，被称作「初始状态」。
还有一系列状态被称为「接受状态」，它们组成了一个特殊的集合。其中，一个状态可能既是「初始状态」，也是「接受状态」。
起初，这个自动机处于「初始状态」。随后，它顺序地读取字符串中的每一个字符，并根据当前状态和读入的字符，按照某个事先约定好的「转移规则」，
从当前状态转移到下一个状态；当状态转移完成后，它就读取下一个字符。当字符串全部读取完毕后，如果自动机处于某个「接受状态」，
则判定该字符串「被接受」；否则，判定该字符串「被拒绝」。

注意：如果输入的过程中某一步转移失败了，即不存在对应的「转移规则」，此时计算将提前中止。在这种情况下我们也判定该字符串「被拒绝」。

一个自动机，总能够回答某种形式的「对于给定的输入字符串 S，判断其是否满足条件 P」的问题。在本题中，条件 P 即为「构成合法的表示数值的字符串」。

自动机驱动的编程，可以被看做一种暴力枚举方法的延伸：它穷尽了在任何一种情况下，对应任何的输入，需要做的事情。

自动机在计算机科学领域有着广泛的应用。在算法领域，它与大名鼎鼎的字符串查找算法「KMP」算法有着密切的关联；在工程领域，它是实现「正则表达式」的基础。

相交链表多看一看。

启发式搜索和记忆化搜索

矩阵顺时针旋转90度

![image-20210805165633603](C:\Users\桁仔\AppData\Roaming\Typora\typora-user-images\image-20210805165633603.png)

